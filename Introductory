# 파이썬 입문
# *프로그래머스스쿨 - 파이썬 입문 (무료) 강의를 바탕으로 공부한 기록

# -----------------------------------------------------------------------

# 파트2 : 변수와 계산

# 변수?
# 변수의 선언 : `identity = '지구인'`
# (1) 변수의 이름 : identity
# (2) 등호(=) : 변수에 값을 저장하라는 의미
# (3) 값 : '지구인'이라고 쓰인 값
# => 즉, identity 라는 변수에 '지구인'이라는 값을 저장하라는 명령

# 변수의 사용
# - `identity = '지구인'` 이라고 변수를 선언하고 나면, 변수의 이름을 가지고 그 값을 불러와서 사용할 수 있음
# - 변수에 새로운 값을 입력하는 방법은 변수를 선언하는 것과 같음

# 주석?
# (1) 한줄 주석 : #
# (2) 여러줄 주석 : """~"""('''~''')

# 숫자와 문자열?

# 숫자 : 계산 가능
# (1) 더하기 +
my_next_age = my_age + 1
# (2) 곱하기 *
multiply = 9 * 9
# (3) 나누기 /
divide = 30 / 5
# (4) 거듭제곱 ** (예) 2의 10승
power = 2 ** 10
# (5) 나머지 %
remainder = 15 % 4
# 15를 4로 나눈 다음의 나머지 = 3

multiply = 9 * 9 # = 81
divide = 30 / 5 # = 6
power = 2 ** 10 # = 1024
reminder = 15 % 4 # = 3
print(multiply, divide, power, reminder)

# 문자열 : 따옴표로 감싸진 글
my_name = 'Python'
# - 텍스트 두개를 더하면 문자열이 이어붙여짐
# - 텍스트는 더하기만 가능하고, 빼기(-)등 다른 계산은 불가능
text = '2015' + '1991' # 하고 나면 text에는 '20151991'이라는 값이 저장

text = '2015' + '1991'
number = 2015 + 1991

print(text)
print(number)

string1 = 'Some text'
string2 = '어떤 텍스트'
string3 = '{}도 {}도 지금 이것도 문자열'.format(string1, string2)

print(string1, string2, string3)

# REPL?

# REPL : Powershell에서 파일 이름 없이 python이라고만 입력하면 나오는 창
# - 파이썬 코드를 한 줄씩 입력해 가면서 테스트 해 볼 수 있는 입력창
# - 종료 방법 : exit()

# Shell 사용법

# Shell 명령어
# (1) pwd : 현재 폴더 경로 출력
# (2) ls : 현재 폴더 내용물 출력
# (3) cd <폴더명> : 다른 폴더로 이동
# (4) cp : 파일을 다른 이름으로 복사
# (5) rm : 파일 삭제하기

# -----------------------------------------------------------------------

# 파트3 : 조건문

# 조건문?
# - 특정 조건에 따라 다른 동작을 할 수 있도록 해 주는 구문

people = 3
apple = 20

# if문

# (1) if : if 조건문의 시작
# (2) people < apple : 실행 여부를 결정하는 조건
# (3) ':' : 조건식의 끝에 콜론 기호 (:)
if people < apple / 5:
    print('신나는 사과 파티! 배 터지게 먹자!')
    # (4) 조건(2)이 참이면 실행할 코드
if apple % people > 0:
    print('사과 수가 맞지 않아! 몇 개는 쪼개 먹자!')
    
if people > apple:
    print('사람이 너무 많아! 몇 명은...')

# boolean 연산
# (1) and : 두 조건이 모두 참인지를 체크
# (2) or : 두 조건 중 하나라도 참인 경우
# (3) not : true/false를 뒤집기 위해 사용

# if else
# else : if의 조건이 맞지 않는 경우 항상 실행됨 (*반드시 if 뒤에 나와야 함)

SCISSOR = '가위'
ROCK = '바위'
PAPER = '보'

WIN = '이겼다!'
DRAW = '비겼다.'
LOSE = '졌다...'

mine = '가위'
yours = '바위'

if mine == yours:
    result = DRAW
else:
    if mine = SCISSOR: # 조건이 참일 때 실행
        if yours == ROCK:
            result = LOSE
        else:
            result = WIN
    elif mine == ROCK: # 다른 조건이 참일 때 실행
    # elif : else 와 if의 결합으로 조건이 맞지 않는 경우 다른 경우를 검사함
        if yours == PAPER:
            result = LOSE
        else:
            result = WIN
    elif mine == PAPER:
        if yours == SCISSOR:
            result = LOSE
        else:
            result = WIN
    else: # 조건이 거짓일 때 실행
        print('이상해요')

print(result)

# 블럭?
# - 함께 실행되는 하나의 코드 덩어리
# - 들여쓰기로 블럭을 구분함
# - 들여쓰기가 어긋나면 오류가 발생함
# - 블럭 안에 다른 블럭이 들어갈 수 있음
# - 내부의 블럭은 외부의 블럭에 종속적임
# - 파이썬 코드 전체를 하나의 블럭으로 볼 수 있음

if True:
    print('블럭에 속한 코드')
    
    if False:
        print('한 줄 더')
    
    if True:
        print('또 한 줄 더')
        
        if True:
            print('블럭 하나 더')
    
    print('블럭의 끝 코드')
    # 들여쓰기가 어긋나면 오류가 발생함
    
print('블럭 끝')

if False:
    print('조건이 안 맞는 코드')
    
    if True:
        print('조건이 맞는 코드')
    
    print('어쨌든 실행되지 않는 코드')

print('다시 블럭 끝')

# -----------------------------------------------------------------------

# 파트4 : 함수

# 함수?
# - 함수는 코드의 덩어리에 이름을 붙인 것
# - 새 함수를 정의할 수 있음
# - print : 미리 만들어진 함수

def function():         # 함수의 정의
        print('안녕, 함수!')

    print('첫줄 실행')
    function()          # 함수의 호출
    print('끝줄 실행')

def function():
    print('안녕, 함수!')
        
print() # 내장 함수
print()
print()

function() # 직접 만든 함수
function()
function()

def print_sqrt():
    r1 = (-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a)
    r2 = (-b - (b ** 2 - 4 * a * c) ** 0.5) / (2 * a)
    
    print('해는 {} 또는 {}'.format(r1, r2))

a = 1
b = 2
c = -8

# a * x^2 + b * x + c = 0, a != 0인 X에 관한 2차 방정식에 대해,
# 근의 공식은

r1 = (-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a)
r2 = (-b - (b ** 2 - 4 * a * c) ** 0.5) / (2 * a)

print('해는 {} 또는 {}'.format(r1, r2))

a = 2
b = -6
c = -8

# 한 번 더 구하려면
print_sqrt()

# 매개변수(Parameter)?
# - 함수를 정의할 때에 사용하는 이름
# 실행 인자 : 함수를 실행할 때에 넘기는 변수, 값

# 매개변수와 실행 인자
# 실행인자(argument) : 실행할 때 넘기는 값
# 매개변수와 실행 인자의 개수는 동일해야 함 (*여러 개일 경우 쉼표로 구분함)

def print_root(a,b,c): # 매개변수
    r1 = (-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a)
    r2 = (-b - (b ** 2 - 4 * a * c) ** 0.5) / (2 * a)
    
    print('해는 {} 또는 {}'.format(r1, r2))

x = 1
y = 2
z = -8

print_root(x, y, z) # 실행 인자

# round() : 반올림된 수를 return함

def print_round(number): # 함수의 정의
    rounded = round(number)
    print(rounded)  

print_round(4.6) # 함수의 호출
print_round(2.2)

# 함수의 값
# - return을 이용하여 값을 돌려줄 수 있음
# - 함수를 사용하는 것은 함수 안의 코드를 모두 실행한 뒤 이 함수의 자리에 return에 있는 값을 넣은 것과 같음
# - 여러 값을 반환하기 위해서는 return 뒤에 여러 값을 쉼표로 나누어 넣기

def add_10(value):
    """value에 10을 더한 값을 올려주는 함수"""
    result = value + 10
    return result

n = add_10(42)
print(n)

n = round(1.5)
print(n)

# -----------------------------------------------------------------------

# 파트5 : 자료형

# 포맷(Format)?
# 문자열.format()
# - 문자열의 대괄호 자리에 format 뒤의 괄호안에 들어있는 값을 하나씩 넣음

number = 20
greeting = '안녕하세요'
place = '문자열 포맷의 세계'
welcome = '환영합니다'

# old way
print(number, '번 손님', greeting, '.', place,
    '에 오신 것을', welcome, '!') # 이게 편할 때도 있지만

base = '{}번 손님, {}. {}에 오신 것을 {}!'
# - 문자열에 포함된 대괄호 개수 보다 format안에 들어 있는 값의 수가 많으면 정상 동작
new_way = base.format(number, greeting, place, welcome) #이게 더 편할 때도 있음

print(base)
print(new_way)

mine = '가위'
yours = '바위'
result = '졌다...' # 이 코드는 만들어 봤어요
print('나는 {}, 너는 {}, 그래서 {}'.format(mine, yours, result))

# 괄호의 수가 변수보다 적을 경우 에러 X
# 괄호의 수가 변수보다 많을 경우 에러 O

# 문자열 (2)

# ' 또는 "로 문자열 만들기
# - ' 또는 "로 글의 양쪽을 감싸면 문자열로 인식함
# - '로 감싼 문자열 안에는 "를 쓸 수 있음
# - " 로 감싼 문자열 안에는 '를 쓸 수 있음

quote = '문법검사기 왈 "직접 인용은 큰따옴표다!"'
emphasize = "'문법검사기'를 인용하다니"
# error = "엄마친구아들이 "파이썬이 좋아"라고 했대"

# 따옴표/큰따옴표 3개로 문자열 만들기
# - 줄바꿈도 인식 가능함
# - 따옴표와 큰따옴표를 섞어 쓸 수 있음

long_string = '''첫째줄은 좋은데
둘째줄도 괜찮을까?'''

quote1 = "가끔은 '와 " + ' "를 모두 쓰기도 해'
quote2 = """가끔은 '와 "를 모두 쓰기도 해"""

print(quote1)
print(quote2)

# error =  "'"이런건 안돼요'"'

# 정수와 실수
# 정수(Integer, int) : 정수끼리 더하거나 곱하거나 빼면 정수
# - 나누면 실수가 나올 수 있으나 나눗샘의 몫만 구하려면 // 연산자 이용
# - 실수를 정수로 바꾸려면 int를 이용함

# 실수 : 부동소수점이라는 표현법을 이용해 소숫점을 표시할 수 있는 숫자
# 관련 위키백과 : https://ko.wikipedia.org/wiki/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90
# - 정수를 실수로 바꾸려면 float를 사용함

five1 = 5
five2 = 5.0
five3 = 5.00000

print(five1)
print(five2)
print(five3)

five4 = 5 * 1
five5 = 5 * 1.0

print(five4)
print(five5)

div1 = 6/5
div2 = 6//5

print(div1)
print(div2)

a = 6
b = 5
print(a == b * (a//b) + (a%b))

print(0.1+0.1 == 0.2) # True
print(0.1+0.1+0.1 == 0.3) # True ??

print(int(5.0)) # 정수
print(float(5)) # 부동소수점
print(5*1.0) # 부동소수점

# 사용자 입력 받기
# 프로그래밍의 3단계 : 1. 사용자 입력 2. 자료 처리 3. 결과 출력

# input()
# 사용자의 키보드 입력을 return함
print('가위 바위 보 중 하나를 내주세요> ', end = ' ')
mine = input()
print('mine:', mine)

# 간단한 print기능을 내장
mine = input('가위 바위 보 중 하나를 내주세요> ')
print('mine:', mine)

# -----------------------------------------------------------------------

# 파트6 : 리스트

# 리스트(list)
# - 여러개의 값을 담을 수 있는 변수

# 값 읽어오기
# - 리스트를 사용할 때에는 0번째가 첫번째가 됨
# 첫번째 값 : list[0]
# 두번째 값 : list[1]
# 뒤에서 첫번째 값 list[-1]
# 리스트에 들어있는 값보다 큰 값을 읽어오려고 하면 에러가 발생함

list1 = ['가위', '바위', '보']
list2 = [37, 23, 10, 33, 29, 40]

print(list1)
print(list2)

print(list1[1])
print(list2[2])
# print(list1[3]) 오류

print(list1[0])

list1[0] = '바위'
print(list1[0])
print(list1)

# print(list1[3])
print(list1[-1]) # 뒤에서 첫번째
print(list1[-3]) # 뒤에서 세번째
# print(list1[-4])

# 값 쓰기
# 변수와 같이 `list1[0] = 10`이라고 하면 list의 첫번째 값이 10으로 변경됨

# 값 추가하기
list2 = [37, 23, 10, 33, 29, 40]
print(list2)

list2.append(16) # append를 이용하면 리스트에 새로운 값이 추가됨
print(list2)

# 뒤에 새로운 리스트를 더하기
list3 = list2 + [16] # list2는 그대로 두고, 새로운 리스트를 만듦
print(list3)

list4 = list2 + list3
print(list4)

n = 12

ownership = n in list3
print(ownership)

# 리스트에 값이 들어있는지 확인하는 방법 : in 연산을 이용

n = 10
if n in list3:
    print('{}은 있어!'.format(n))
    
print(list4)

# 리스트에서 필요 없는 값을 지우는 방법
# (1) del을 이용해서 특정 위치의 값을 지우기
del list4[12]
print(list4)
# (2) remove를 이용해서 특정 값을 지우기
# : 여러개의 값이 있는 경우 가장 앞에 있는 하나만 지워짐
list4.remove(40)
print(list4)

# -----------------------------------------------------------------------

# 파트7 : for 반복문

# for in 반복문
# - 코드를 필요한 만큼 반복해서 실행함

patterns = ['가위', '보', '보', '가위', '가위', '가위', '보', '가위', '바위', '보']
for pattern in patterns:
    print(pattern)

# for in range
# range : 필요한 만큼의 숫자를 만들어내는 유용한 기능

for i in [0, 1, 2, 3, 4]:
    print(i)

for i in range(10): # ~= [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    print(i)
    
names = ['철수', '영희', '바둑이', '길동']

for i in range(4):
    name = names[i]
    print('{}번: {}'.format(i+1, name))
    
# range 괄호에 len을 넣으면 리스트의 길이만큼 반복할 수 있음

for i in range(len(names)):
    name = names[i]
    print('{}번 : {}'.format(i + 1, name))
    
# enumerate : 리스트가 있는 경우 순서와 리스트의 값을 전달하는 기능
for i, name in enumerate(names):
    print('{}번: {}'.format(i+1, name))
    
for i in range(11172):
    print(chr(44032+i), end='')

# 순회할 리스트가 정해져 있을 경우 : for in list
# 순회할 횟수가 정해져 있을 경우 : for in range()

# -----------------------------------------------------------------------

# 파트8 : 모듈

# 모듈
# - 미리 만들어진 코드를 가져와 쓰는 방법
# - import (모듈명)
# - 사용 방법 : (모듈명).(모듈 구성요소)

# 수학과 관련된 기능
import math

# 무작위와 관련된 기능
import random

# 인터넷의 내용을 가져오는 기능
import urllib.request

def get_web(url):
    """URL을 넣으면 페이지 내용을 돌려주는 함수"""
    import urllib.request
    response = urllib.request.urlopen(url)
    data = response.read()
    decoded = data.decode('utf-8')
    return decoded
url = input('웹 페이지 주소?')
content = get_web(url)
print(content)

# 모듈 만들기
# (1) 사용할 함수, 메소드 코드를 작성한 모듈 파일을 생성하기
# (2) 모듈이 쓰일 파일에 import를 사용하여 모듈을 호출
# (3) 사용 방법은 기존의 모듈과 동일함
# *사용자가 만든 모듈과 모듈을 쓸 파일이 동일 폴더에 있어야 함

def random_rsp():
    """무작위로 가위바위보를 낸다"""
    import random
    return random.choice(['가위', '바위', '보'])

PAPER = '보'
SCISSOR = '가위'
ROCK = '바위'

# 모듈 사용하기

import my_module

selected = my_module.random_rsp()
print(selected)
print('가위?', my_module.SCISSOR == selected)

# -----------------------------------------------------------------------

# 파트9 : 활용

# 프로그래밍 검색 요령
"""
- 검색은 구글(Google)로 하기
- 키워드에 파이썬3 혹은 python3를 포함하기
- 코드를 포함하는 글을 찾도록 하기
- 간단한 예제는 REPL을 사용하여 예제 테스트 하기
"""

# datetime
# https://docs.python.org/ko/3/library/datetime.html
import datetime, time

# 년, 월, 일을 입력하여 date 객체 생성하기
datetime.date(2023, 12, 28)

# 타임스탬프로 date 객체 생성하기
datetime.date.fromtimestamp(time.time())

# 오늘 날짜의 date 객체 생성하기
datetime.date.today()

now = datetime.datetime.now()
print (now) # 출력 : 2023-12-28 03:59:53.939282

# 해당 달의 최대 일수를 넘어선 경우 ValueError 발생
# datetime.date(2009, 2, 31)
# ValueError: day is out of range for month

# 문서 찾기?

# 공식 문서 : https://docs.python.org/3/
# - 파이썬 내장 모듈과 함수의 정보가 필요할 때
# - 필요한 내용을 둘러보고 싶을 때

# 구글 또는 스택오버플로우
# 스택오버플로우(Stackoverflow) : https://stackoverflow.com/
# - 문제의 구체적인 해결 방법이 알고 싶을 때 이용하기

# -----------------------------------------------------------------------

# 파트10 : 딕셔너리와 튜플

# 딕셔너리(Dictionary)란?
# - 여러 값을 저장해두고 필요한 값을 꺼내 쓰는 기능
# - 이름표를 이용하여 값을 꺼내서 사용함

"""
  - 딕셔너리명 = {
    '이름표1':'값1',
    '이름표2':'값2',
    '이름표3':'값3'
    }
"""

# (1) 딕셔너리 값 수정하기
dict = {'one':'abc', 'two':'def'}
dict['one'] = 11

print(dict)

# (2) 딕셔너리 값 추가하기
dict['three'] = 2

print(dict)

# (3) 딕셔너리 값 삭제하기
del(dict['one'])
dict.pop('two')

print(dict)

# (4) 딕셔너리 반복문
# 이름표 = key

ages = {'Tod':35, 'Jane':23, 'Paul':62}
print(ages)

for key in ages.keys(): # keys() 생략 가능
    print(key)
    
for value in ages.values():
    print(value)
    
# Key와 Value를 모두 가져올 수도 있음
for key in ages:
    print('{}의 나이는 {} 입니다'.format(key, ages[key]))
for key, value in ages.items():
    print('{}의 나이는 {} 입니다'.format(key, value))

# (5) 리스트와 비교

# - 리스트와 공통점
"""
1. 생성
    list = [ 1, 2 ,3 ]
    dict = { 'one':1, 'two':2 }

2. 호출
    list[ 0 ]
    dict[ 'one' ]

3. 삭제
    del( list[ 0 ] )
    del( dict[ 'one' ] )

4. 개수 확인
    len( list )
    len( dict )

5. 값 확인
    2 in list
    'two' in dict.keys( )

6. 전부 삭제
    list.clear( )
    dict.clear( )
"""

# 리스트와 차이점
"""
1. 순서
    List : 삭제 시 순서가 바뀌기 때문에 인덱스에 대한 값이 바뀜
    Dictionary : key로 값을 가져오기 때문에 삭제 여부와 상관 없음

2. 결합
    list1 + list2
    dict1.update( dict2 )
"""

# 튜플?
# 튜플은 한번 정해진 순서를 바꿀 수 없음
# 튜플 선언하기
tuple1 = (1,2,3) # (1,2,3)
tuple2 - 1,2,3 # (1,2,3)
tuple2 - 1,2,3 # (1,2,3)

mylist = [1,2,3]
tuple3 = tuple(list) # (1,2,3)

if tuple1 == tuple2 == tuple3:
    print("tuple1과 tuple2와 tuple3은 모두 같습니다.")

# 패킹(Packing) & 언패킹(Unpacking)?

# 패킹(Packing) : 하나의 변수에 여러개의 값을 넣는 것
# 언패킹(Unpacking) : 패킹된 변수에서 여러개의 값을 꺼내오는 것

a, b = 1, 2
print("a : " + a) # 1
print("b : " + b) # 2

c = (3, 4)
print("c : " + c) # (3, 4)

d, e = c # 언패킹(Unpacking)
print("d : " + d) # 3
print("e : " + e) # 4

f = d, e # 패킹(Packing)
print("f : " + f) # (3, 4) 

x = 5
y = 10
temp = x
x = y
y = temp
print("x : " + x) # 10
print("y : " + y) # 5

# 튜플의 활용
# - 두 변수의 값을 바꿀 때 임시변수가 필요 없음
# - 함수의 리턴 값으로 여러 값을 전달할 수 있음

# 튜플을 이용한 함수의 리턴값

# (1) 튜플 리스트 활용
list = [1,2,3,4,5]
"""for i, v in enumerate(list):
    print('{}번째 값: {}'.format(i,v))"""
    
"""for a in enumerate(list):
    print('{}번째 값: {}'.format(a[0],a[1]))"""

for a in enumerate(list):
    print('{}번째 값: {}'.format(*a))

# (2) 튜플 딕셔너리 활용
ages = {'Tod':35, 'Jane':23, 'Paul':62}
"""for key, val in ages.items():
    print('{}의 나이는:{}'.format(key,val))"""

"""for a in ages.items():
    print('{}의 나이는:{}'.format(a[0], a[1]))"""
    
for a in ages.items():
    print('{}의 나이는:{}'.format(*a))

# -----------------------------------------------------------------------

# 파트11 : while문과 반복 제어

# while문?
# - 조건이 참인 경우 계속 실행하는 반복문
# - for 반복문으로 작성한 코드는 while 반복문으로 작성 할 수 있음

"""selected = None
while selected not in ['가위', '바위', '보']:
    selected = input('가위, 바위, 보 중에 선택하세요>')

print('선택된 값은: ',selected)"""

patterns = ['가위', '보', '보']
"""for pattern in patterns:
    print(pattern)"""
length = len(patterns)
i = 0

"""for i in range(len(patterns)):
    print(patterns[i])"""
i = 0
while i < length:
    print(patterns[i])
    i = i+1

# Break & Continue?

# list = [1,2,3,5,7,2,5,237,55]

# Break
for val in list:
  if val % 3 == 0:
      print(val)
      break # 반복문을 종료시키는 기능

# Continue
# for i in range(10):
#   if i%2 != 0:
#     print(i)
#     print(i)
#     print(i)
#     print(i)

for i in range(10):
  if i%2 == 0:
    continue # 반복문의 나머지 부분을 보지 않고 처음으로 돌아가는 기능
  print(i)
  print(i)
  print(i)
  print(i)

# for문과 while문에서도 똑같이 동작함

# try ~ except

# 예외 처리
list = []
# list[0] : 인덱스 에러가 발생함
text = 'abc'
# number = int(text) : 'abc'는 숫자로 바꿀 수 없기 때문에 밸류 에러가 발생함

text = '100%'
try:
  # 에러가 발생할 가능성이 있는 코드
    number = int(text)
except ValueError: # 에러 종류
    # 에러가 발생 했을 경우 처리할 코드
    print('{}는 숫자가 아니네요.'.format(text))

def safe_pop_print(list, index):
    try:
        print(list.pop(index))
    except IndexError:
        print('{} index의 값을 가져올 수 없습니다.'.format(index))

safe_pop_print([1,2,3],5)

def safe_pop_print(list, index):
    if index<len(list):
        print(list.pop(index))
    else:
        print('{} index의 값을 가져올 수 없습니다.'.format(index))

# 예외처리 대신에 if else 를 사용할 수 있음

safe_pop_print([1,2,3],5)

try:
    import my_module
except ImportError:
    print("모듈이 없습니다.")

    try:
    a = 3/0
except ZeroDivisionError:
    print("0으로 나눌 수 없습니다.")
